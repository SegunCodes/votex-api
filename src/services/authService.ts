import jwt from "jsonwebtoken";
import { ethers } from "ethers";
import { DecodedToken } from "../types/index.d";

const jwtSecret = process.env.JWT_SECRET;

if (!jwtSecret) {
  console.error(
    "JWT_SECRET is not defined in environment variables. JWT operations will fail."
  );
  process.exit(1);
}

/**
 * Generates a JWT token for a given user payload.
 * @param {object} payload - The data to include in the token (e.g., userId, role, walletAddress).
 * @param {string} expiresIn - Token expiration time (e.g., '1h', '7d').
 * @returns {string} The signed JWT token.
 */
export const generateToken = (
  payload: object,
  expiresIn: string = "1h"
): string => {
  return jwt.sign(payload, jwtSecret, { expiresIn });
};

/**
 * Verifies a JWT token.
 * @param {string} token - The JWT token to verify.
 * @returns {DecodedToken | null} The decoded payload if valid, null otherwise.
 */
export const verifyToken = (token: string): DecodedToken | null => {
  try {
    return jwt.verify(token, jwtSecret) as DecodedToken;
  } catch (error) {
    console.error("JWT verification failed:", (error as Error).message);
    return null;
  }
};

/**
 * Verifies an Ethereum wallet signature.
 * @param {string} message - The original message that was signed.
 * @param {string} signature - The signature generated by the wallet.
 * @returns {string | null} The address that signed the message if valid, null otherwise.
 */
export const verifyWalletSignature = (
  message: string,
  signature: string
): string | null => {
  try {
    const recoveredAddress = ethers.verifyMessage(message, signature);
    return recoveredAddress;
  } catch (error) {
    console.error(
      "Wallet signature verification failed:",
      (error as Error).message
    );
    return null;
  }
};
